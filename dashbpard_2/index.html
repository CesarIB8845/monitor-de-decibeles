<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monitor de Decibeles - MAX4466</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #f98012;  /* Color naranja principal */
            --primary-dark: #e6710b;   /* Naranja oscuro para hover */
            --secondary-color: #1a237e;
            --error-color: #ff4444;
            --background-color: #2d3748;
            --bar-background: #e2e8f0;
            --text-color: #ffffff;
        }
        
        body { 
            font-family: 'Poppins', sans-serif; 
            text-align: center; 
            background: var(--background-color); 
            color: var(--text-color); 
            padding: 20px;
            margin: 0;
            min-height: 100vh;
        }

        h1 {
            color: var(--primary-color);
            margin-bottom: 40px;
            font-weight: 600;
        }

        .status {
            color: var(--text-color);
            margin: 10px;
            font-style: italic;
            padding: 8px;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.2);
        }

        .container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
            max-width: 1200px;
            margin-left: auto;
            margin-right: auto;
        }

        .micro-block {
            background: var(--secondary-color);
            padding: 20px;
            border-radius: 10px;
            width: 45%;
            min-width: 280px;
            box-sizing: border-box;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .bar-container { 
            width: 100%; 
            background: var(--bar-background); 
            height: 40px; 
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            margin: 15px 0;
        }

        .bar { 
            height: 100%; 
            width: 0%; 
            background: var(--primary-color); /* Color naranja por defecto */
            transition: width 0.3s ease, background-color 0.3s ease; 
            position: relative;
        }

        .db-value {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-color);
            font-weight: bold;
            z-index: 1;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        h3, .subtitle {
            color: var(--text-color);
            margin: 5px 0;
        }

        .subtitle {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .controls {
            margin: 20px 0;
        }

        button {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Poppins', sans-serif;
            font-size: 16px;
            margin: 0 10px;
            transition: background 0.3s;
        }

        button:hover {
            background: var(--primary-dark);
        }

        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }

        .device-selector {
            margin: 20px 0;
        }

        select {
            padding: 8px 15px;
            border-radius: 5px;
            font-family: 'Poppins', sans-serif;
            background: var(--secondary-color);
            color: white;
            border: 1px solid var(--primary-color);
        }

        @media (max-width: 768px) {
            .micro-block {
                width: 100%;
            }
            
            .container {
                gap: 15px;
            }
        }
    </style>
</head>
<body>
    <h1>Monitor de Decibeles - MAX4466</h1>
    <div id="status" class="status">Selecciona los dispositivos de entrada</div>

    <div class="device-selector">
        <label for="mic1Select">Micrófono 1 (MAX4466):</label>
        <select id="mic1Select" disabled>
            <option value="">Cargando dispositivos...</option>
        </select>
        
        <label for="mic2Select" style="margin-left: 20px;">Micrófono 2 (MAX4466):</label>
        <select id="mic2Select" disabled>
            <option value="">Cargando dispositivos...</option>
        </select>
    </div>

    <div class="controls">
        <button id="startBtn">Iniciar Monitoreo</button>
        <button id="stopBtn" disabled>Detener Monitoreo</button>
        <button id="calibrateBtn" disabled>Calibrar Micrófonos</button>
    </div>

    <div class="container">
        <div class="micro-block">
            <h3>Micrófono 1 - MAX4466</h3>
            <div class="bar-container">
                <div id="bar1" class="bar">
                    <span id="value1" class="db-value">0 dB</span>
                </div>
            </div>
            <div class="subtitle">Sección de Dirección</div>
        </div>

        <div class="micro-block">
            <h3>Micrófono 2 - MAX4466</h3>
            <div class="bar-container">
                <div id="bar2" class="bar">
                    <span id="value2" class="db-value">0 dB</span>
                </div>
            </div>
            <div class="subtitle">Micrófono en Canchas</div>
        </div>
    </div>

    <script>
        // Configuración
        const CONFIG = {
            SAMPLE_RATE: 30,    // Muestras por segundo (30 fps)
            MAX_DB: 120,        // Valor máximo de decibeles
            MIN_DB: 10,         // Valor mínimo de decibeles
            CALIBRATION_TIME: 3, // Segundos para calibración
            BUFFER_SIZE: 2048    // Tamaño del buffer de audio
        };

        // Estado de la aplicación
        const appState = {
            audioContext: null,
            analysers: [null, null],
            microphoneStreams: [null, null],
            isRecording: false,
            calibrationValues: [0, 0],
            animationId: null,
            audioInputDevices: []
        };

        // Elementos del DOM
        const DOM = {
            status: document.getElementById('status'),
            startBtn: document.getElementById('startBtn'),
            stopBtn: document.getElementById('stopBtn'),
            calibrateBtn: document.getElementById('calibrateBtn'),
            mic1Select: document.getElementById('mic1Select'),
            mic2Select: document.getElementById('mic2Select'),
            bars: [
                document.getElementById('bar1'),
                document.getElementById('bar2')
            ],
            values: [
                document.getElementById('value1'),
                document.getElementById('value2')
            ]
        };

        // Cargar dispositivos de audio disponibles
        async function loadAudioDevices() {
            try {
                updateStatus("Buscando dispositivos de audio...", "info");
                
                // Necesitamos permisos de micrófono para enumerar dispositivos
                await navigator.mediaDevices.getUserMedia({ audio: true });
                
                const devices = await navigator.mediaDevices.enumerateDevices();
                appState.audioInputDevices = devices.filter(device => device.kind === 'audioinput');
                
                // Actualizar selectores
                DOM.mic1Select.innerHTML = '';
                DOM.mic2Select.innerHTML = '';
                
                appState.audioInputDevices.forEach((device, index) => {
                    const option1 = document.createElement('option');
                    option1.value = device.deviceId;
                    option1.text = device.label || `Micrófono ${index + 1}`;
                    DOM.mic1Select.appendChild(option1);
                    
                    const option2 = document.createElement('option');
                    option2.value = device.deviceId;
                    option2.text = device.label || `Micrófono ${index + 1}`;
                    DOM.mic2Select.appendChild(option2);
                });
                
                DOM.mic1Select.disabled = false;
                DOM.mic2Select.disabled = false;
                
                if (appState.audioInputDevices.length >= 2) {
                    updateStatus("Selecciona ambos micrófonos MAX4466 y haz clic en Iniciar", "info");
                } else {
                    updateStatus("Error: Se necesitan al menos 2 dispositivos de entrada", "error");
                }
                
            } catch (error) {
                handleError(error);
            }
        }

        // Iniciar monitoreo de ambos micrófonos
        async function startMonitoring() {
            try {
                const deviceId1 = DOM.mic1Select.value;
                const deviceId2 = DOM.mic2Select.value;
                
                if (!deviceId1 || !deviceId2) {
                    throw new Error("Debes seleccionar ambos micrófonos");
                }
                
                if (deviceId1 === deviceId2) {
                    throw new Error("Debes seleccionar dispositivos diferentes para cada micrófono");
                }
                
                updateStatus("Iniciando monitoreo de ambos micrófonos...", "info");
                
                // Crear contexto de audio
                appState.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Configurar ambos micrófonos
                for (let i = 0; i < 2; i++) {
                    const deviceId = i === 0 ? deviceId1 : deviceId2;
                    
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            deviceId: { exact: deviceId },
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false
                        }
                    });
                    
                    appState.microphoneStreams[i] = appState.audioContext.createMediaStreamSource(stream);
                    appState.analysers[i] = appState.audioContext.createAnalyser();
                    appState.analysers[i].fftSize = CONFIG.BUFFER_SIZE;
                    
                    appState.microphoneStreams[i].connect(appState.analysers[i]);
                }
                
                appState.isRecording = true;
                
                DOM.startBtn.disabled = true;
                DOM.stopBtn.disabled = false;
                DOM.calibrateBtn.disabled = false;
                DOM.mic1Select.disabled = true;
                DOM.mic2Select.disabled = true;
                
                updateStatus("Monitoreo activo - Ambos micrófonos funcionando", "success");
                
                // Iniciar bucle de análisis
                analyzeAudio();
                
            } catch (error) {
                handleError(error);
            }
        }

        // Detener monitoreo
        function stopMonitoring() {
            if (appState.animationId) {
                cancelAnimationFrame(appState.animationId);
                appState.animationId = null;
            }
            
            // Desconectar ambos micrófonos
            for (let i = 0; i < 2; i++) {
                if (appState.microphoneStreams[i]) {
                    appState.microphoneStreams[i].disconnect();
                    const stream = appState.microphoneStreams[i].mediaStream;
                    stream.getTracks().forEach(track => track.stop());
                    appState.microphoneStreams[i] = null;
                    appState.analysers[i] = null;
                }
            }
            
            if (appState.audioContext) {
                if (appState.audioContext.state !== 'closed') {
                    appState.audioContext.close();
                }
                appState.audioContext = null;
            }
            
            appState.isRecording = false;
            
            DOM.startBtn.disabled = false;
            DOM.stopBtn.disabled = true;
            DOM.calibrateBtn.disabled = true;
            DOM.mic1Select.disabled = false;
            DOM.mic2Select.disabled = false;
            
            updateStatus("Monitoreo detenido", "info");
            
            // Resetear visualización
            updateBar(0, 0);
            updateBar(1, 0);
        }

        // Calibrar ambos micrófonos
        async function calibrateMicrophones() {
            if (!appState.isRecording) return;
            
            DOM.calibrateBtn.disabled = true;
            updateStatus(`Calibrando... Por favor mantén silencio durante ${CONFIG.CALIBRATION_TIME} segundos`, "info");
            
            // Tomar muestras durante el tiempo de calibración
            let samples1 = [];
            let samples2 = [];
            const startTime = Date.now();
            const endTime = startTime + (CONFIG.CALIBRATION_TIME * 1000);
            
            function collectCalibrationData() {
                if (Date.now() >= endTime) {
                    // Calcular valores promedio de calibración
                    const sum1 = samples1.reduce((a, b) => a + b, 0);
                    const sum2 = samples2.reduce((a, b) => a + b, 0);
                    
                    appState.calibrationValues[0] = sum1 / samples1.length;
                    appState.calibrationValues[1] = sum2 / samples2.length;
                    
                    updateStatus(
                        `Calibración completada. Mic1: ${appState.calibrationValues[0].toFixed(1)} dB, Mic2: ${appState.calibrationValues[1].toFixed(1)} dB`,
                        "success"
                    );
                    DOM.calibrateBtn.disabled = false;
                    return;
                }
                
                const db1 = getDecibelLevel(0);
                const db2 = getDecibelLevel(1);
                
                samples1.push(db1);
                samples2.push(db2);
                
                appState.animationId = requestAnimationFrame(collectCalibrationData);
            }
            
            collectCalibrationData();
        }

        // Analizar audio en tiempo real
        function analyzeAudio() {
            if (!appState.isRecording) return;
            
            for (let i = 0; i < 2; i++) {
                const db = getDecibelLevel(i);
                const adjustedDB = Math.max(0, db - appState.calibrationValues[i]);
                updateBar(i, adjustedDB);
            }
            
            // Continuar el bucle
            appState.animationId = requestAnimationFrame(analyzeAudio);
        }

        // Obtener nivel de decibeles desde el analizador
        function getDecibelLevel(micIndex) {
            const analyser = appState.analysers[micIndex];
            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(dataArray);
            
            // Calcular promedio de todas las frecuencias
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            const average = sum / dataArray.length;
            
            // Convertir a decibeles (ajuste empírico)
            const db = 20 * Math.log10(average / 255 * 100);
            
            return isFinite(db) ? db : CONFIG.MIN_DB;
        }

        function updateBar(micIndex, value) {
            const bar = DOM.bars[micIndex];
            const dbLabel = DOM.values[micIndex];
            
            // Calcular porcentaje basado en el máximo de decibeles configurado
            const percentage = Math.max(0, Math.min(100, (value / CONFIG.MAX_DB) * 100));
            
            bar.style.width = `${percentage}%`;
            dbLabel.textContent = `${value.toFixed(1)} dB`;
            
            // Cambiar color solo si es silencio (manteniendo naranja para todo lo demás)
            if (value < CONFIG.MIN_DB) {
                bar.style.backgroundColor = 'var(--error-color)'; // Rojo solo para silencio
            } else {
                bar.style.backgroundColor = 'var(--primary-color)'; // Naranja para cualquier otro nivel
            }
        }

        function updateStatus(message, type = "info") {
            DOM.status.textContent = message;
            DOM.status.style.backgroundColor = type === "error" ? 'rgba(255, 0, 0, 0.2)' : 
                                              type === "success" ? 'rgba(0, 255, 0, 0.2)' : 
                                              'rgba(0, 0, 255, 0.2)';
        }

        function handleError(error) {
            console.error('Error:', error);
            updateStatus(`Error: ${error.message}`, "error");
            
            // Restablecer controles
            DOM.startBtn.disabled = false;
            DOM.stopBtn.disabled = true;
            DOM.calibrateBtn.disabled = true;
            DOM.mic1Select.disabled = false;
            DOM.mic2Select.disabled = false;
            
            // Detener cualquier proceso en curso
            if (appState.animationId) {
                cancelAnimationFrame(appState.animationId);
                appState.animationId = null;
            }
        }

        // Event Listeners
        DOM.startBtn.addEventListener('click', startMonitoring);
        DOM.stopBtn.addEventListener('click', stopMonitoring);
        DOM.calibrateBtn.addEventListener('click', calibrateMicrophones);

        // Manejar cierre de la página
        window.addEventListener('beforeunload', () => {
            if (appState.isRecording) {
                stopMonitoring();
            }
        });

        // Inicializar
        loadAudioDevices();
    </script>
</body>
</html>



